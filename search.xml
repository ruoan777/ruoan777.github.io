<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SSO流程</title>
    <url>/2021/08/16/SSO%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>单点登录英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</p>
</blockquote>
<p><img src="/images/SSO.png" alt="asd"></p>
<blockquote>
<p>上图是CAS(Central Authentication Service)官网上的标准流程，具体流程如下：</p>
</blockquote>
<ol>
<li><p>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</p>
</li>
<li><p>跳转到CAS server，即SSO登录系统，以后图中的CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。</p>
</li>
<li><p>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</p>
</li>
<li><p>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</p>
</li>
<li><p>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</p>
</li>
<li><p>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</p>
</li>
<li><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p>
</li>
<li><p>用户访问app2系统，app2系统没有登录，跳转到SSO。</p>
</li>
<li><p>由于SSO已经登录了，不需要重新登录认证。</p>
</li>
<li><p>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</p>
</li>
<li><p>app2拿到ST，后台访问SSO，验证ST是否有效。</p>
</li>
<li><p>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</p>
</li>
</ol>
<h2 id="关于sso另一个版本的介绍"><a href="#关于sso另一个版本的介绍" class="headerlink" title="关于sso另一个版本的介绍"></a>关于sso另一个版本的介绍</h2><p>一次「从 A 系统引发登录，到 B 系统不用登录」的完整流程<br><img src="/images/sso1.jpeg" alt="asd"></p>
<ol>
<li>用户进入 A 系统，没有登录凭证（ticket），A 系统给他跳到 SSO</li>
<li>SSO 没登录过，也就没有 sso 系统下没有凭证（注意这个和前面 A ticket 是两回事），输入账号密码登录</li>
<li>SSO 账号密码验证成功，通过接口返回做两件事：一是种下 sso 系统下凭证（记录用户在 SSO 登录状态）；二是下发一个 ticket</li>
<li>客户端拿到 ticket，保存起来，带着请求系统 A 接口</li>
<li>系统 A 校验 ticket，成功后正常处理业务请求</li>
<li>此时用户第一次进入系统 B，没有登录凭证（ticket），B 系统给他跳到 SSO</li>
<li>SSO 登录过，系统下有凭证，不用再次登录，只需要下发 ticket</li>
<li>客户端拿到 ticket，保存起来，带着请求系统 B 接口</li>
</ol>
<blockquote>
<p>上面的过程看起来没问题，实际上很多 APP 等端上这样就够了。但在浏览器下不见得好用。</p>
</blockquote>
<p><img src="/images/sso2.jpeg" alt="asd"></p>
<blockquote>
<p>对浏览器来说，SSO 域下返回的数据要怎么存，才能在访问 A 的时候带上？浏览器对跨域有严格限制，cookie、localStorage 等方式都是有域限制的。<br>这就需要也只能由 A 提供 A 域下存储凭证的能力。一般我们是这么做的：</p>
</blockquote>
<p><img src="/images/sso3.jpeg" alt="asd"></p>
<blockquote>
<p>图中我们通过颜色把浏览器当前所处的域名标记出来。注意图中灰底文字说明部分的变化。</p>
</blockquote>
<ol>
<li>在 SSO 域下，SSO 不是通过接口把 ticket 直接返回，而是通过一个带 code 的 URL 重定向到系统 A 的接口上，这个接口通常在 A 向 SSO 注册时约定</li>
<li>浏览器被重定向到 A 域下，带着 code 访问了 A 的 callback 接口，callback 接口通过 code 换取 ticket</li>
<li>这个 code 不同于 ticket，code 是一次性的，暴露在 URL 中，只为了传一下换 ticket，换完就失效</li>
<li>callback 接口拿到 ticket 后，在自己的域下 set cookie 成功</li>
<li>在后续请求中，只需要把 cookie 中的 ticket 解析出来，去 SSO 验证就好<br>访问 B 系统也是一样</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a class="link"   href="https://zhuanlan.zhihu.com/p/281414244" >前端鉴权的兄弟们：cookie、session、token、jwt、单点登录<i class="fas fa-external-link-alt"></i></a> </p>
]]></content>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2021/06/20/ThreadLocal/</url>
    <content><![CDATA[<p>ThreadLocal作为业务上下文传递的经典技术手段在中间件、技术与业务框架中广泛大量使用。<br>它的特性是将变量绑定在执行的线程上，天生具有线程安全的特性。</p>
<p>ThreadLocal 的经典使用场景，一般是作为类的private static fields in classes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">public class ThreadId &#123;</span><br><span class="line">     // Atomic integer containing the next thread ID to be assigned</span><br><span class="line">     private static final AtomicInteger nextId = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">     // Thread local variable containing each thread&#x27;s ID</span><br><span class="line">     private static final ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line">         new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">             @Override </span><br><span class="line">             protected Integer initialValue() &#123;</span><br><span class="line">                 return nextId.getAndIncrement();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     // Returns the current thread&#x27;s unique ID, assigning it if necessary</span><br><span class="line">     public static int get() &#123;</span><br><span class="line">         return threadId.get();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal源码分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadLocal&lt;T&gt;&#123;</span><br><span class="line">    public T get()&#123;&#125;</span><br><span class="line">    public void set()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class ThreadLocalMap&#123;</span><br><span class="line">        static class Entry entends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>get方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public T get()&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if(map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry entry = map.getEntry(this);</span><br><span class="line">        if(entry != null) &#123;</span><br><span class="line">            return (T)entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
这里会有两种情况会调用到setInitialValue方法</li>
</ul>
<ul>
<li>ThreadLocalMap本身为空，说明当前线程还没有初始化过该map</li>
<li>map.getEntry(this)为空，说明当前ThreadLocal还没有设置过值，而又是ThreadLocal#get方法调用过来的，所以需要调用initialValue方法。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private T setInitialValue()&#123;</span><br><span class="line">    //其实就是上面定义ThreadLocal变量时重写的初始化方法</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if(map != null)  &#123;</span><br><span class="line">        map.put(this, value)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void createMap(Thread t, T value)&#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>当然，更多的时候，应用需要的实际上是把 任务提交给线程池时的ThreadLocal值传递到任务执行时，而这样的需求在使用ThreadLocal的时候是满足不了的，需要使用增强版的transmittable-thread-local</p>
]]></content>
  </entry>
  <entry>
    <title>HEXO基本用法</title>
    <url>/2021/09/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>java中主线程和子线程的关系</title>
    <url>/2021/05/23/java%E4%B8%AD%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="1-Main线程是个非守护线程，不能设置成守护线程。"><a href="#1-Main线程是个非守护线程，不能设置成守护线程。" class="headerlink" title="1.Main线程是个非守护线程，不能设置成守护线程。"></a>1.Main线程是个非守护线程，不能设置成守护线程。</h2><p>这是因为，main线程是由java虚拟机在启动的时候创建的。main方法开始执行的时候，主线程已经创建好并在运行了。对于运行中的线程，调用Thread.setDaemon()会抛出异常<br><code>Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException</code>。测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MainTest&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">        System.out.println(&quot; parent thread begin &quot;);</span><br><span class="line">        Thread.currentThread().setDaemon(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Main线程结束，其他线程一样可以正常运行。"><a href="#2-Main线程结束，其他线程一样可以正常运行。" class="headerlink" title="2.Main线程结束，其他线程一样可以正常运行。"></a>2.Main线程结束，其他线程一样可以正常运行。</h2><p>主线程，只是个普通的非守护线程，用来启动应用程序，不能设置成守护线程；除此之外，它跟其他非守护线程没有什么不同。主线程执行结束，其他线程一样可以正常执行。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ParentTest&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;parent thread begin &quot;);</span><br><span class="line">        </span><br><span class="line">        ChildThread t1 = new ChildThread(&quot;thread1&quot;);</span><br><span class="line">        ChildThread t2 = new ChildThread(&quot;thread2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;parent thread over &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class ChildThread extends Thread&#123;</span><br><span class="line">    private String name = null;</span><br><span class="line"> </span><br><span class="line">    public ChildThread(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead begin&quot;);</span><br><span class="line"> </span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(this.name + &quot;--child thead over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–程序运行结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parent thread begin </span><br><span class="line">parent thread over </span><br><span class="line">thread2--child thead begin</span><br><span class="line">thread1--child thead begin</span><br><span class="line">thread2--child thead over</span><br><span class="line">thread1--child thead over</span><br></pre></td></tr></table></figure>
<p>这样其实是很合理的，按照操作系统的理论，进程是资源分配的基本单位，线程是CPU调度的基本单位。对于CPU来说，其实并不存在java的主线程和子线程之分，都只是个普通的线程。进程的资源是线程共享的，只要进程还在，线程就可以正常执行，换句话说线程是强依赖于进程的。也就是说，线程其实并不存在互相依赖的关系，一个线程的死亡从理论上来说，不会对其他线程有什么影响。</p>
<h2 id="3-Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程。"><a href="#3-Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程。" class="headerlink" title="3.Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程。"></a>3.Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程。</h2><p>java虚拟机(相当于进程)退出的时机是：虚拟机中所有存活的线程都是守护线程。只要还有存活的非守护线程虚拟机就不会退出，而是等待非守护线程执行完毕；反之，如果虚拟机中的线程都是守护线程，那么不管这些线程的死活java虚拟机都会退出。测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ParentTest&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;parent thread begin &quot;);</span><br><span class="line">        </span><br><span class="line">        ChildThread t1 = new ChildThread(&quot;thread1&quot;);</span><br><span class="line">        ChildThread t2 = new ChildThread(&quot;thread2&quot;);</span><br><span class="line">        t1.setDaemon(true);</span><br><span class="line">        t2.setDaemon(true);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;parent thread over &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ChildThread extends Thread&#123;</span><br><span class="line">    private String name = null;</span><br><span class="line">    public ChildThread(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead begin&quot;);</span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this.name + &quot;--child thead over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parent thread begin</span><br><span class="line">parent thread over</span><br><span class="line">thread1--child thead begin</span><br><span class="line">thread2--child thead begin</span><br></pre></td></tr></table></figure>
<p>在这种情况下，的确主线程退出，子线程就立刻结束了，但是这是属于JVM的底层实现机制，并不是说主线程和子线程之间存在依赖关系。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a class="link"   href="https://blog.csdn.net/aitangyong/article/details/16858273" >文章1<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://bbs.csdn.net/topics/360195074?page=2" >文章2<i class="fas fa-external-link-alt"></i></a>  </p>
<blockquote>
<p>1.main所在的线程结束,和其它子线程是否结束没有任何关系。<br>2.main所在的线程结束,demon线程是否退出也和它没有任何关系，而是看整个jvm进程内是否还有非<br>demon线程，如果没有，整个jvm进程退出。换句话说jvm只要发现不再有非demon线程就退出，main线程是否退出没有任何关系。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>leetcode236二叉树的最近公共祖先</title>
    <url>/2021/05/21/leetcode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h3 id="leetcode-236-二叉树的最近公共祖先-与上题的区别在于它只是一棵普通的二叉树"><a href="#leetcode-236-二叉树的最近公共祖先-与上题的区别在于它只是一棵普通的二叉树" class="headerlink" title="leetcode 236.二叉树的最近公共祖先(与上题的区别在于它只是一棵普通的二叉树)"></a>leetcode 236.二叉树的最近公共祖先(与上题的区别在于它只是一棵普通的二叉树)</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line">6      _2       0       8</span><br><span class="line">      /  \</span><br><span class="line">      7   4</span><br></pre></td></tr></table></figure>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p>说明:<br>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。</p>
<h4 id="以根节点为起点，往左右分支上寻找，如果找到了-p-或-q-节点，则返回该节点。否则，继续向叶子节点寻找，假想一下，如果一直递归到-null-还是找不到该节点，那么说明这个分支上不存在该节点。"><a href="#以根节点为起点，往左右分支上寻找，如果找到了-p-或-q-节点，则返回该节点。否则，继续向叶子节点寻找，假想一下，如果一直递归到-null-还是找不到该节点，那么说明这个分支上不存在该节点。" class="headerlink" title="以根节点为起点，往左右分支上寻找，如果找到了 p 或 q 节点，则返回该节点。否则，继续向叶子节点寻找，假想一下，如果一直递归到 null 还是找不到该节点，那么说明这个分支上不存在该节点。"></a>以根节点为起点，往左右分支上寻找，如果找到了 <code>p</code> 或 <code>q</code> 节点，则返回该节点。否则，继续向叶子节点寻找，假想一下，如果一直递归到 <code>null</code> 还是找不到该节点，那么说明这个分支上不存在该节点。</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root==p || root==q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<span class="comment">//往左分支上寻找</span></span><br><span class="line">        TreeNode* right=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<span class="comment">//往右分支上寻找</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right)<span class="comment">//说明 p 和 q 是分布在 root 两侧，返回即可</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left)<span class="comment">//说明在 left 分支上找到 p 或 q 节点，返回即可</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>mac 多版本Java随时切换方法</title>
    <url>/2021/05/28/mac-%E5%A4%9A%E7%89%88%E6%9C%ACJava%E9%9A%8F%E6%97%B6%E5%88%87%E6%8D%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="jenv神器简单操作命令"><a href="#jenv神器简单操作命令" class="headerlink" title="jenv神器简单操作命令"></a>jenv神器简单操作命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install jenv</span><br><span class="line">vim .bash_profile</span><br><span class="line">add如下的环境变量到bash_profile</span><br><span class="line"></span><br><span class="line"># java 1.8</span><br><span class="line">JAVA8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home</span><br><span class="line"></span><br><span class="line"># java 11</span><br><span class="line">JAVA11_HOME=/usr/local/Cellar/openjdk@11/11.0.10</span><br><span class="line"></span><br><span class="line"># 如果没有使用alias命令则默认使用jdk8</span><br><span class="line"># JAVA_HOME=$JAVA8_HOME</span><br><span class="line"></span><br><span class="line"># alias命令动态切换JDK版本</span><br><span class="line">alias jdk8=&quot;export JAVA_HOME=$JAVA8_HOME&quot;</span><br><span class="line">alias jdk11=&quot;export JAVA_HOME=$JAVA11_HOME&quot;</span><br><span class="line"></span><br><span class="line">:wq退出</span><br><span class="line"></span><br><span class="line">echo &#x27;export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &#x27;eval &quot;$(jenv init -)&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line"></span><br><span class="line">jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home</span><br><span class="line">jenv add /usr/local/Cellar/openjdk@11/11.0.10</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ jenv versions</span><br><span class="line">* system (set by /Users/ruoan/.jenv/version)</span><br><span class="line">  1.8</span><br><span class="line">  1.8.0.251</span><br><span class="line">  11</span><br><span class="line">  11.0</span><br><span class="line">  11.0.10</span><br><span class="line">  openjdk64-11.0.10</span><br><span class="line">  oracle64-1.8.0.251</span><br></pre></td></tr></table></figure>
<p>最后使用shell/local/global进行切换即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jenv shell/local/global 1.8</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>my first blog</title>
    <url>/2021/05/21/my-first-blog/</url>
    <content><![CDATA[<p>–</p>
<h1 id="HELLO-WORLD"><a href="#HELLO-WORLD" class="headerlink" title="HELLO WORLD"></a>HELLO WORLD</h1>]]></content>
  </entry>
  <entry>
    <title>tomcat</title>
    <url>/2021/07/05/tomcat/</url>
    <content><![CDATA[<p><img src="/images/tomcat.png" alt="asd"></p>
<blockquote>
<p>catalina 本身是一个成熟的软件，设计开发结构十分优雅，功能结构模块化。从 servlet 容器的功能角度看，catalian 可以划分为两大模块: connector 模块和 container 模块。</p>
</blockquote>
<p>这里 connector 的功能是将用户请求与 container 连接。 connector 的任务的是为每个接收到的 HTTP 请求建立 request 对象和 response 对象。然后，将处理过程交给 container 模块。 container 模块从 connector 模块中接收到 request 对象和 response 对象，并负责调用相应的 servlet 的服务方法。</p>
<p>tomcat4 的连接器：等待 http 请求，创建 request 和 response 对象，调用org.apache.catalina.Container 的 invoke 方法将 request 对象和 response 对象传入 container。在 invoke 方法中， container 负责载入 servlet 类，调用其 call 方法，管理 session，记录日志等工作</p>
<p>HttpConnector 里面不仅仅要设置container，还要维护了一个 HttpProcessor 的对象池，从而避免频繁的创建 HttpProcessor 对象，<br>每个 HttpProcessor 对象负责解析请求行和请求头，填充request对象，因此，每个 HttpProcessor 对象都关联一个 request 对象和 response 对象。HttpProcessor 的构造函数会调用 HttpConnector 的 createRequest 方法和 createResponse 方法</p>
<p>一个比较简单的示例是下面这段代码<br>下面的代码展示了tomcat利用 HttpConnector 连接用户，利用 HttpProcessor 处理请求的一个较为完整的调用链</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class Bootstrap &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HttpConnector connector = new HttpConnector();</span><br><span class="line">        SimpleContainer container = new SimpleContainer();</span><br><span class="line">        connector.setContainer(container);</span><br><span class="line">        try &#123;</span><br><span class="line">            connector.initialize();</span><br><span class="line"></span><br><span class="line">            //core!!!</span><br><span class="line">            connector.start();</span><br><span class="line"></span><br><span class="line">            // make the application wait until we press any key.</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HttpConnector implements Connector, Lifecycle, Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void start() throws LifecycleException &#123;</span><br><span class="line">        // Validate and update our current state</span><br><span class="line">        if (started)</span><br><span class="line">            throw new LifecycleException</span><br><span class="line">                (sm.getString(&quot;httpConnector.alreadyStarted&quot;));</span><br><span class="line">        threadName = &quot;HttpConnector[&quot; + port + &quot;]&quot;;</span><br><span class="line">        lifecycle.fireLifecycleEvent(START_EVENT, null);</span><br><span class="line">        started = true;</span><br><span class="line"></span><br><span class="line">        // 在这个方法里面，创建了一个线程 thread = new Thread(this, threadName);即把当前HttpConnector 作为Thread参数传入，然后启动该线程</span><br><span class="line">        threadStart();</span><br><span class="line"></span><br><span class="line">        // 按照配置好的minProcessors值，创建指定个数的 HttpProcessor</span><br><span class="line">        while (curProcessors &lt; minProcessors) &#123;</span><br><span class="line">            if ((maxProcessors &gt; 0) &amp;&amp; (curProcessors &gt;= maxProcessors))</span><br><span class="line">                break;</span><br><span class="line">            HttpProcessor processor = newProcessor();</span><br><span class="line">            recycle(processor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //这里的run由上面的threadStart启动</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!stopped) &#123;</span><br><span class="line">                Socket socket = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket = serverSocket.accept();</span><br><span class="line">                    if (connectionTimeout &gt; 0)</span><br><span class="line">                        socket.setSoTimeout(connectionTimeout);</span><br><span class="line">                    socket.setTcpNoDelay(tcpNoDelay);</span><br><span class="line">                &#125;</span><br><span class="line">                HttpProcessor processor = createProcessor();</span><br><span class="line">                if (processor == null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        log(sm.getString(&quot;httpConnector.noProcessor&quot;));</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                processor.assign(socket);</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (threadSync) &#123;</span><br><span class="line">                threadSync.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注意在创建 HttpProcessor 就调用了start方法，启动了对应的线程</span><br><span class="line">private HttpProcessor newProcessor() &#123;</span><br><span class="line">    HttpProcessor processor = new HttpProcessor(this, curProcessors++);</span><br><span class="line">    if (processor instanceof Lifecycle) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ((Lifecycle) processor).start();</span><br><span class="line">        &#125; catch (LifecycleException e) &#123;</span><br><span class="line">            log(&quot;newProcessor&quot;, e);</span><br><span class="line">            return (null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    created.addElement(processor);</span><br><span class="line">    return (processor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面启动了线程之后，下面的run方法就开始启动了，不停地在循环中处理进来的请求</span><br><span class="line">final class HttpProcessor implements Lifecycle, Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // Process requests until we receive a shutdown signal</span><br><span class="line">        while (!stopped) &#123;</span><br><span class="line">            // Wait for the next socket to be assigned</span><br><span class="line">            Socket socket = await();</span><br><span class="line">            if (socket == null)</span><br><span class="line">                continue;</span><br><span class="line">            // Process the request from this socket</span><br><span class="line">            try &#123;</span><br><span class="line">                //core方法</span><br><span class="line">                process(socket);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                log(&quot;process.invoke&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">            // Finish up this request</span><br><span class="line">            connector.recycle(this);</span><br><span class="line">        &#125;</span><br><span class="line">        // Tell threadStop() we have shut ourselves down successfully</span><br><span class="line">        synchronized (threadSync) &#123;</span><br><span class="line">            threadSync.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(Socket socket) &#123;</span><br><span class="line">        ...</span><br><span class="line">        connector.getContainer().invoke(request, response);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleContainer implements Container &#123;</span><br><span class="line">        public void invoke(Request request, Response response) throws IOException, ServletException &#123;</span><br><span class="line">        String servletName = ((HttpServletRequest) request).getRequestURI();</span><br><span class="line">        servletName = servletName.substring(servletName.lastIndexOf(&quot;/&quot;) + 1);</span><br><span class="line">        URLClassLoader loader = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            URL[] urls = new URL[1];</span><br><span class="line">            URLStreamHandler streamHandler = null;</span><br><span class="line">            File classPath = new File(WEB_ROOT);</span><br><span class="line">            String repository = (new URL(&quot;file&quot;, null, classPath.getCanonicalPath() + File.separator)).toString();</span><br><span class="line">            urls[0] = new URL(null, repository, streamHandler);</span><br><span class="line">            loader = new URLClassLoader(urls);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        Class myClass = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            myClass = loader.loadClass(servletName);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        Servlet servlet = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            servlet = (Servlet) myClass.newInstance();</span><br><span class="line">            servlet.service((HttpServletRequest) request, (HttpServletResponse) response);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ModernServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig config) &#123;</span><br><span class="line">        System.out.println(&quot;ModernServlet -- init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(&quot;text/html&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.print(&quot;HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n&quot;);</span><br><span class="line">        out.println(&quot;&lt;html&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;head&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;title&gt;Modern Servlet&lt;/title&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;/head&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;body&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        out.println(&quot;&lt;h2&gt;Headers&lt;/h2&quot;);</span><br><span class="line">        Enumeration headers = request.getHeaderNames();</span><br><span class="line">        while (headers.hasMoreElements()) &#123;</span><br><span class="line">            String header = (String) headers.nextElement();</span><br><span class="line">            out.println(&quot;&lt;br&gt;&quot; + header + &quot; : &quot; + request.getHeader(header));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.println(&quot;&lt;br&gt;&lt;h2&gt;Method&lt;/h2&quot;);</span><br><span class="line">        out.println(&quot;&lt;br&gt;&quot; + request.getMethod());</span><br><span class="line"></span><br><span class="line">        out.println(&quot;&lt;br&gt;&lt;h2&gt;Parameters&lt;/h2&quot;);</span><br><span class="line">        Enumeration parameters = request.getParameterNames();</span><br><span class="line">        while (parameters.hasMoreElements()) &#123;</span><br><span class="line">            String parameter = (String) parameters.nextElement();</span><br><span class="line">            out.println(&quot;&lt;br&gt;&quot; + parameter + &quot; : &quot; + request.getParameter(parameter));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.println(&quot;&lt;br&gt;&lt;h2&gt;Query String&lt;/h2&quot;);</span><br><span class="line">        out.println(&quot;&lt;br&gt;&quot; + request.getQueryString());</span><br><span class="line"></span><br><span class="line">        out.println(&quot;&lt;br&gt;&lt;h2&gt;Request URI&lt;/h2&quot;);</span><br><span class="line">        out.println(&quot;&lt;br&gt;&quot; + request.getRequestURI());</span><br><span class="line"></span><br><span class="line">        out.println(&quot;&lt;/body&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;/html&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>具体过程如下:<br>(1)connector 创建 request 和 response 对象;<br>(2)connector 调用 StandardContext 实例的 invoke 方法;<br>(3)StandardContext 接着调用其 pipeline 的 invoke 方法， StandardContext 中 pipeline 的 basic valve 是<br>StandardContextValve，因此，StandardContext 的 pipeline 会调用 StandardContextValve 的 invoke 方法; (4)StandardContextValve 的 invoke 方法获取 wrapper 处理请求，调用 wrapper 的 invoke 方法; (5)StandardWrapper 是 Wrapper 接口的标准实现 ，StandardWrapper 实例的 invoke 方法会调用 其 pipeline<br>的 invoke 方法;<br>(6)StandardWrapper 的 pipeline 中的 basic valve 是 StandardWrapperValve，因此，会调用其 invoke 方<br>法，StandardWrapperValve调用 wrapper 的 allocate 方法获取 servlet 实例; (7)allocate 方法调用 load 方法载入 servlet 类，若已经载入，则无需重复载入; (8)load 方法调用 servlet 的 init 方法;<br>(9)StandardWrapperValve调用 servlet 的 service 方法。</p>
]]></content>
  </entry>
  <entry>
    <title>使用GitHub Actions自动部署</title>
    <url>/2021/09/12/%E4%BD%BF%E7%94%A8GitHub-Actions%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>真乃神器，比如说，这篇文章就是通过下面的方式 push 上去的。amazing<br><a class="link"   href="https://juejin.cn/post/6943895271751286821#heading-8" >如何使用 GitHub Actions 自动部署 Hexo 博客<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>使用GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>反爬系统架构</title>
    <url>/2021/06/02/%E5%8F%8D%E7%88%AC%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>反爬2.0系统架构</p>
</blockquote>
<p><img src="/images/ched.jpg" alt="asd"></p>
]]></content>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/06/19/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode now = head;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode newHead = null;</span><br><span class="line">        while(now!=null)&#123;</span><br><span class="line">            ListNode next = now.next;</span><br><span class="line">            if(next==null)&#123;</span><br><span class="line">                newHead=now;</span><br><span class="line">            &#125;</span><br><span class="line">            now.next=pre;</span><br><span class="line">            pre=now;</span><br><span class="line">            now=next;</span><br><span class="line">        &#125;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if(head==null||head.next==null)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead=reverseList(head.next);</span><br><span class="line">        head.next.next=head;</span><br><span class="line">        head.next=null;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>和远程服务器通信的一些命令</title>
    <url>/2021/05/30/%E5%92%8C%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>将本地客户端的公钥放在服务端，下次连接服务器就不再需要使用密码了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ～/.ssh</span><br><span class="line">ssh-copy-id root@远程服务器地址(ip或者域名均可)</span><br><span class="line">然后登陆到远程服务器 会发现.ssh目录下多了一个文件，而文件的内容正好是本地客户端的公钥</span><br><span class="line">[root@guest .ssh]# ls</span><br><span class="line">authorized_keys</span><br><span class="line">[root@guest .ssh]# cat authorized_keys</span><br></pre></td></tr></table></figure>


<p>可以给服务端设置别名，方面登陆<br>在客户端执行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd .ssh</span><br><span class="line">ls</span><br><span class="line">vim config</span><br></pre></td></tr></table></figure>
<p>把如下的配置拷贝进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 给服务器起的别名</span><br><span class="line">	HostName 服务器的ip地址</span><br><span class="line">	User root</span><br><span class="line">	Port 22</span><br></pre></td></tr></table></figure>

<p>客户端和服务端直接拷贝文件<br><code>scp -r .hallo root@远程服务器地址 Desktop/temp</code></p>
]]></content>
  </entry>
  <entry>
    <title>域名解析+建站</title>
    <url>/2021/05/22/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90+%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>域名解析基本原理如下图</p>
</blockquote>
<p><img src="/images/dns.png" alt="asd"></p>
<h3 id="正式步骤"><a href="#正式步骤" class="headerlink" title="正式步骤"></a>正式步骤</h3><ol start="0">
<li><p>自行申请域名,申请vps(下面以centos为例)</p>
</li>
<li><p>修改系统时间为北京时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date -R</span><br><span class="line">timedatectl set-local-rtc 1</span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure></li>
<li><p>安装相关依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br><span class="line">yum install curl</span><br><span class="line">yum install netcat</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li><p>安装dat和release.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh</span><br><span class="line">curl -O https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-dat-release.sh</span><br><span class="line"></span><br><span class="line">bash install-release.sh</span><br><span class="line">bash install-dat-release.sh</span><br></pre></td></tr></table></figure></li>
<li><p>编辑配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/etc/v2ray</span><br><span class="line">vim config.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;port&quot;: 443,</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,    </span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;clients&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;id&quot;: &quot;这里是随机生成的uuid&quot;,</span><br><span class="line">            &quot;alterId&quot;: 16</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;ws&quot;,</span><br><span class="line">        &quot;security&quot;: &quot;tls&quot;,</span><br><span class="line">        &quot;tlsSettings&quot;: &#123;</span><br><span class="line">          &quot;certificates&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;certificateFile&quot;: &quot;/etc/v2ray/v2ray.crt&quot;,</span><br><span class="line">              &quot;keyFile&quot;: &quot;/etc/v2ray/v2ray.key&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>安装acem.sh证书生成工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -O -  https://get.acme.sh | sh</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>生成v2ray目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/  </span><br><span class="line">mkdir v2ray   </span><br><span class="line">cd ~</span><br></pre></td></tr></table></figure></li>
<li><p>临时关闭防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></li>
<li><p>生成证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ~/.acme.sh/acme.sh --issue -d 这里是域名 --alpn -k ec-256</span><br></pre></td></tr></table></figure>
<p>这一步如果有如下报错，说明防火墙可能没有关闭, 如果使用的centos系统，关闭防火墙就可以成功获取证书，即还是要执行上一步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://enterpr1se.info/2017/10/v2ray-gfw-setup/6/  </span><br><span class="line">请选择: 正在获取SSL证书，请稍等..  </span><br><span class="line">[Thu Nov 14 18:41:28 UTC 2019] Standalone mode.  </span><br><span class="line">[Thu Nov 14 18:41:28 UTC 2019] Creating domain key  </span><br><span class="line">[Thu Nov 14 18:41:28 UTC 2019] The domain key is here: /root/.acme.sh/XXX.xyz_ecc/XXX.xyz.key  </span><br><span class="line">[Thu Nov 14 18:41:28 UTC 2019] Single domain=&#x27;XXX.xyz&#x27;  </span><br><span class="line">[Thu Nov 14 18:41:28 UTC 2019] Getting domain auth token for each domain  </span><br><span class="line">[Thu Nov 14 18:41:30 UTC 2019] Getting webroot for domain=&#x27;XXX.xyz&#x27;  </span><br><span class="line">[Thu Nov 14 18:41:31 UTC 2019] Verifying: XXX.xyz  </span><br><span class="line">[Thu Nov 14 18:41:31 UTC 2019] Standalone mode server  </span><br><span class="line">[Thu Nov 14 18:41:35 UTC 2019] XXX.xyz:Verify error:Fetching http://XXX.xyz/.well-known/acme-challenge/TvxkrixcAQt1YDCONZ_l1wOcmDfZ6NgK68JWS8_Npck: Error getting validation data  </span><br><span class="line">[Thu Nov 14 18:41:35 UTC 2019] Please add &#x27;--debug&#x27; or &#x27;--log&#x27; to check more details.  </span><br><span class="line">[Thu Nov 14 18:41:35 UTC 2019] See: https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh  </span><br></pre></td></tr></table></figure></li>
<li><p>证书和密钥安装到指定路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd etc/v2ray  </span><br><span class="line">sudo ~/.acme.sh/acme.sh --installcert -d 这里是域名 --fullchainpath /etc/v2ray/v2ray.crt --keypath /etc/v2ray/v2ray.key --ecc</span><br><span class="line"></span><br><span class="line">记得要修改文件权限</span><br><span class="line">chmod 644 /etc/v2ray/v2ray.key  </span><br></pre></td></tr></table></figure></li>
<li><p>查询tls开启状态<br><a class="link"   href="https://www.ssllabs.com/ssltest/index.html" >查询tls<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>重启且设置且开机启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart v2ray</span><br><span class="line">systemctl enable v2ray</span><br><span class="line"></span><br><span class="line">查看当前状态</span><br><span class="line">sudo systemctl status -l v2ray</span><br></pre></td></tr></table></figure></li>
<li><p>防火墙设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Centos7默认安装了firewalld，如果没有安装的话，可以使用  </span><br><span class="line">yum install firewalld firewalld-config  </span><br><span class="line">进行安装。</span><br><span class="line"></span><br><span class="line">开启防火墙</span><br><span class="line">systemctl start firewalld </span><br><span class="line">设置开机启动</span><br><span class="line">systemctl enable firewalld</span><br><span class="line">查看当前防火墙状态</span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line">在指定区域打开端口（记得重启防火墙）</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp  --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp  --permanent</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line">重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>卸载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash install-release.sh --remove</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a class="link"   href="https://www.youtube.com/watch?v=mYXnhzAQZR8&ab_channel=ComeBey" >教程<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://blog.csdn.net/u011846257/article/details/54707864" >防火墙相关<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://dash.cloudflare.com/" >域名管理<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.namesilo.com/" >域名注册<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.rootfw.com/posts/3e3bccee.html" >脚本参考<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>如何保持数据库和缓存当中的数据一致性</title>
    <url>/2021/09/10/%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%BD%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>说实话，这个问题老生长谈了，其中的逻辑也很绕，之前没有做过一个系统性的整理，今天闲来无事，作如下总结，以供后续查阅。</p>
</blockquote>
<h3 id="一-更新数据库，更新缓存方案"><a href="#一-更新数据库，更新缓存方案" class="headerlink" title="一. 更新数据库，更新缓存方案"></a>一. 更新数据库，更新缓存方案</h3><ol>
<li>先更新数据库，再更新缓存<ul>
<li>假如后一步失败<br>   更新数据库成功，更新缓存失败，则意味着下一次读取的时候，拿到的还是缓存里面的旧数据。</li>
<li>并发问题<br>   假如AB两个线程同时对某一数据X进行操作，X=1<br>   A更新数据库中的X=1<br>   B更新数据库中的X=2<br>   B更新缓存中的X=2<br>   A更新缓存中的X=1<br>   经过这一顿操作，X在数据库中的值为2，在缓存中的值为1，数据不一致</li>
</ul>
</li>
<li>先更新缓存，再更新数据库<ul>
<li>假如后一步失败<br>   缓存更新成功，但数据库更新失败，则读请求每次可以拿到更新后的数据，但一旦缓存过期，则下一次又读到了老数据</li>
<li>并发问题<br>   假如AB两个线程同时对某一数据X进行操作，X=1<br>   A更新缓存中的X=1<br>   B更新缓存中的X=2<br>   B更新数据库中的X=2<br>   A更新数据库中的X=1<br>   经过这一顿操作，X在数据库中的值为1，在缓存中的值为2，数据不一致  </li>
</ul>
</li>
</ol>
<blockquote>
<p>可见，关于并发问题的解决，一般可以通过加分布式锁来完成，比如两条线程要更改同一条数据，则必须在更改之前获取分布式锁，获取成功了才可以对数据进行操作。<br>拿不到锁的线程，返回失败，等待下次重试。<br>这样的方案，对于那种频繁更改数据的场景似乎不太友好，<br>第一、获取分布式锁开销不小，可能会有很大的性能损耗。<br>第二、从缓存利用率的角度来看，这样的方案真的好吗？数据每次发生变化都无脑更新缓存，但事实上缓存中的数据不一定会马上被读取，这样缓存中就放了<br>很多不常用的数据，造成了空间浪费。<br>第三、有的时候，缓存中的数据并不是和数据库中一一对应，而是有可能经过一系列的计算之后才放入缓存，这样就带来了机器CPU的损耗。<br>综上，更新数据库，更新缓存方案 不仅缓存利用率不高，还会造成机器性能的浪费。</p>
</blockquote>
<h3 id="二-更新数据库，删除缓存方案"><a href="#二-更新数据库，删除缓存方案" class="headerlink" title="二. 更新数据库，删除缓存方案"></a>二. 更新数据库，删除缓存方案</h3><ol>
<li><strong>先更新数据库，再删除缓存</strong><ul>
<li>假如后一步失败<br>   数据库更新成功，缓存删除失败，则意味着下一次读取的时候，拿到的还是缓存里面的旧数据。</li>
<li>并发问题<br>   假如AB两个线程同时对某一数据X进行操作，X=1<br>   X假如在缓存中不存在<br>   A读取到数据库中的X=1<br>   B更新数据库中的X=2<br>   B删除缓存中的X<br>   A更新缓存中的X=1<br>   经过这一顿操作，X在数据库中的值为2，在缓存中的值为1，数据不一致  </li>
</ul>
</li>
</ol>
<blockquote>
<p>这种方案虽然也会出现数据不一致的可能，但在实际的生产场景中，出现的概率并不高，因为要发生这样的不一致，需要以下几个条件同时满足</p>
</blockquote>
<ul>
<li>缓存正好过期，需要更新</li>
<li>读请求正好进来，和写请求并发</li>
<li>更新数据库+删除缓存的时间&lt;读取数据库+更新缓存的时间<br>事实上，第三条一般就是不满足的，一般更新数据库需要对数据加行锁或其他悲观/乐观锁，这一步的开销不低，一般花费的时间会大于读取数据库的时间</li>
</ul>
<ol start="2">
<li>先删除缓存，再更新数据库<ul>
<li>假如后一步失败<br>   缓存删除成功，但数据库更新失败，则下一次读请求进来，拿到的是数据库没有更新的数据，当然有问题。</li>
<li>并发问题<br>   假如AB两个线程同时对某一数据X进行操作，X=1<br>   B删除缓存中的X<br>   A读取缓存没读到，去读数据库拿到了X=1<br>   B更新数据库中的X=2<br>   A更新缓存X=1<br>   经过这一顿操作，X在数据库中的值为2，在缓存中的值为1，数据不一致  </li>
</ul>
</li>
</ol>
<blockquote>
<p>上述一，二两种解决思路，不管哪一种遇到了第二步更新失败的场景，都会带来问题，所以这个问题需要着重解决<br>这里的思路是重试，即失败重试，这里又面对一个问题，第一次失败了一般紧接着第二次也会失败，重试多少次，重试也会占用CPU资源？<br>更好的方案是使用异步重试，业内通常使用的技术方案是使用消息队列，第二步失败后发消息到一个重试队列当中去，由队列异步去重试。<br>还有一种，如果不想使用消息队列，可以订阅数据库的binlog,拿到具体的数据，然后再去操作删除缓存。</p>
</blockquote>
<p>最后，关于使用先更新数据库，再删除缓存的方案，还有一种场景也可以拓展，就是主从库延迟和延迟双删问题。</p>
<ul>
<li>如果使用「先更新数据库，再删除缓存」方案，其实也会发生不一致：</li>
<li>线程 A 更新主库 X = 2（原值 X = 1）</li>
<li>线程 A 删除缓存</li>
<li>线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）</li>
<li>从库「同步」完成（主从库 X = 2）</li>
<li>线程 B 将「旧值」写入缓存（X = 1）</li>
<li>最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。</li>
</ul>
<p>怎么解决这个问题？其实很简单，还是把缓存删除，但是不能立刻删，要延迟删，即缓存延迟双删策略。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>解决redis和mysql一致性问题：首先只能减少，不能强一致性，采用先更新数据库，再删除缓存，为保证两步都完成，需加消息对列或订阅更新日志辅助；</li>
<li>主库同步和缓存的问题：先更新主库，为了等主库数据同步到从库的时间差，采用延迟删除缓存(为防止步骤未完成，可将延迟删除消息发到队列中)或双删缓存；</li>
<li>为保证误差：尽可能减少主从库的延迟。</li>
<li>不管使用了哪一种方案，选择了缓存作为中间件，在带来了性能提升的同时，必然要做出一些牺牲。</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a class="link"   href="https://www.zhihu.com/question/319817091/answer/2110995185" >如何保持mysql和redis中数据的一致性<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>缓存专辑</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端/服务端 同步/异步</title>
    <url>/2021/08/22/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="同步-异步的不同实现"><a href="#同步-异步的不同实现" class="headerlink" title="同步/异步的不同实现"></a>同步/异步的不同实现</h3><blockquote>
<p>首先澄清一个概念，异步，同步和oneway是三件事。</p>
</blockquote>
<ul>
<li>异步，归根结底你还是需要关心结果的，但可能不是当时的时间点关心，可以用轮询或者回调等方式处理结果；</li>
<li>同步是需要当时关心 的结果的；</li>
<li>而oneway是发出去就不管死活的方式，这种对于某些完全对可靠性没有要求的场景还是适用的，但不是我们重点讨论的范畴。</li>
</ul>
<p>回归来看，任何的RPC都是存在客户端异步与服务端异步的，而且是可以任意组合的：客户端同步对服务端异步，客户端异步对服务端异步，客户端同步对服务端同步，客户端异步对服务端同步。 对于客户端来说，同步与异步主要是拿到一个Result，还是Future(Listenable)的区别。实现方式可以是线程池，NIO或者其他事件机制，这里先不展开讲。 服务端异步可能稍微难理解一点，这个是需要RPC协议支持的。参考servlet 3.0规范，服务端可以吐一个future给客户端，并且在future done的时候通知客户端。 整个过程可以参考下面的代码：</p>
<ul>
<li><p>客户端同步服务端异步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; future = request(server);//server立刻返回future</span><br><span class="line">synchronized(future)&#123;</span><br><span class="line">    while(!future.isDone())&#123;</span><br><span class="line">        future.wait();//server处理结束后会notify这个future，并修改isdone标志</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return future.get();</span><br></pre></td></tr></table></figure></li>
<li><p>客户端同步服务端同步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Result result = request(server);</span><br></pre></td></tr></table></figure></li>
<li><p>客户端异步服务端同步(这里用线程池的方式)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; future = executor.submit(new Callable()&#123;</span><br><span class="line">    public void call&lt;Result&gt;()&#123;</span><br><span class="line">        result = request(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">return future;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端异步服务端异步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; future = request(server);//server立刻返回future</span><br><span class="line">return future</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>上面说了这么多，其实是想让大家脱离两个误区：</p>
</blockquote>
<ul>
<li>RPC只有客户端能做异步，服务端不能。</li>
<li>异步只能通过线程池。</li>
</ul>
<h3 id="服务端使用异步最大的好处是什么呢？"><a href="#服务端使用异步最大的好处是什么呢？" class="headerlink" title="服务端使用异步最大的好处是什么呢？"></a>服务端使用异步最大的好处是什么呢？</h3><p>说到底，是解放了线程和I/O。<br>试想服务端有一堆I/O等待处理，如果每个请求都需要同步响应，每条消息都需要结果立刻返回，那么就几乎没法做I/O合并 （当然接口可以设计成batch的，但可能batch发过来的仍然数量较少）。<br>而如果用异步的方式返回给客户端future，就可以有机会进行I/O的合并，把几个批次发过来的消息一起落地（这种合并对于MySQL等允许batch insert的数据库效果尤其明显），并且彻底释放了线程。不至于说来多少请求开多少线程，能够支持的并发量直线提高。 </p>
<p>来看第二个误区，返回future的方式不一定只有线程池。换句话说，可以在线程池里面进行同步操作，也可以进行异步操作，也可以不使用线程池使用异步操作（NIO、事件）。 回到消息队列的议题上，我们当然不希望消息的发送阻塞主流程（前面提到了，server端如果使用异步模型，则可能因消息合并带来一定程度上的消息延迟），所以可以先使用线程池提交一个发送请求，主流程继续往下走。 但是线程池中的请求关心结果吗？Of course，必须等待服务端消息成功落地，才算是消息发送成功。所以这里的模型，准确地说事客户端半同步半异步（使用线程池不阻塞主流程，但线程池中的任务需要等待server端的返回），server端是纯异步。客户端的线程池wait在server端吐回的future上，直到server端处理完毕，才解除阻塞继续进行。 总结一句，同步能够保证结果，异步能够保证效率，要合理的结合才能做到最好的效率。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a class="link"   href="https://tech.meituan.com/2016/07/01/mq-design.html" >美团技术团队-消息队列设计精要<i class="fas fa-external-link-alt"></i></a> </p>
]]></content>
  </entry>
</search>
